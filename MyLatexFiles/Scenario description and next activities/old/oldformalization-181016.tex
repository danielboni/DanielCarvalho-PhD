% ----------------------------------- DEFINITION 1 ABSTRACT SERVICE --------------------------------- %

\noindent \textbf{Definition 1 (\textsl{Abstract service})}. An \textsl{abstract service} describes the small piece of function performed by a \textsl{service} deployed by a \textsl{data provider}. For instance, retrieve weather information, book a hotel, retrieve infected patients, among others. The \textsl{abstract service} is defined as follows: $A \ (\overline{I}; \ \overline{O})$ where $A$ is the name which identifies the \textsl{abstract service}. $\overline{I}$ and $\overline{O}$ are a set of comma-separated input and output parameters, respectively.

% ----------------------------------- DEFINITION 2 QUERY --------------------------------- %
\bigskip
\noindent \textbf{Definition 2 (\textsl{Query})}.
An user \textsl{query} $Q$ is defined as a sequence of \textsl{abstract services} followed by a set of \textsl{user requirements} in accordance with the grammar:
%
\begin{center}
\begin{math}
Q (\overline{I}_{h}; \overline{O}_{h}) := A_{1}(\overline{I}_{1l};
\overline{O}_{1l}), A_{2}(\overline{I}_{2l}; \overline{O}_{2l}), ..,  A_{n}(\overline{I}_{nl}; \overline{O}_{nl}),R_{1},R_{2}, .., R_{m}
\end{math}
\end{center}
%
The \textsl{query} is defined in terms of \textsl{abstract services} ($A_{1}, A_{2}, .., A_{n}$) including a set of \textsl{user requirements} ($R_{1},R_{2}, .., R_{m}$). 
The left-hand of the definition is called the \textit{head}; and the right-hand is the \textit{body}. 
A \textsl{query} $Q$ includes a set of input $\overline{I}$ and output $\overline{O}$ variables, respectively.
Variables in the \textit{head} are identified by $\overline{I}_{h}$ and $\overline{O}_{h}$, and called \textit{head} variables. 
They appear in the \textit{head} and in the \textit{body} definition. 
Variables appearing only in the \textit{body} are identified by $\overline{I}_{l}$ and $\overline{O}_{l}$, and are called \textit{local} variables. \textit{Head} variables can be accessed and shared among different services. On the other hand, \textit{local} variables can be used only by the service which define them.
%

% ----------------------------------- DEFINITION 3 USER REQUIREMENTS --------------------------------- %
\bigskip
\noindent \textbf{Definition 3 (\textsl{User requirement})}.
An \textsl{user requirement} $r$ is in the form $x \otimes c$, where $x$ is an identifier; $c$ is a constant; and $\otimes \in\lbrace \geq, \leq, =, \neq, <, >\rbrace$. 
%
The \textsl{user requirements} can be associated to single \textsl{service} or to the entire composition. For instance, the \textsl{total response time} is obtained by adding the \textsl{response time} of each \textsl{service} involved in the composition.

% ----------------------------------- DEFINITION 4 USER REQUIREMENTS DOMAIN --------------------------------- %
\bigskip
\noindent \textbf{Definition 4 (\textsl{Requirement domain})}. A \textsl{requirement domain (D)} groups \textsl{user requirements} which specify information in the same domain, and which can be comparable among each other. For instance, a \textsl{requirement domain} \textit{time} includes time-related \textsl{user requirements} such as \textsl{response time}, \textsl{total response time}, \textsl{latency}, among others.

% ----------------------------------- DEFINITION 5 REQUIREMENTS DOMAIN EQUIVALENCE --------------------------------- %
\bigskip
\noindent \textbf{Definition 5 (\textsl{Requirement domain equivalence})}. A \textsl{requirement domain} $D_{1}$ is equivalent to a \textsl{requirement domain} $D_{2}$, represented by $D_{1} \cong D_{2}$, iff: $\forall r_{i} \in D_{1}, \ \exists r_{j} \in D_{2} \ \vert \ r_{i}.x = r_{j}.x \ and \ \vert D_{1} \vert = \vert D_{2} \vert$.

% ----------------------------------- DEFINITION 6 REQUIREMENTS DOMAIN CONTAININMENT --------------------------------- %
\bigskip
\noindent \textbf{Definition 6 (\textsl{Requirement domain containment})}. A \textsl{requirement domain} $D_{1}$ is contained in a \textsl{requirement domain} $D_{2}$, represented by $D_{1} \subset D_{2}$, iff: $\forall r_{i} \in D_{1}, \ \exists r_{j} \in D_{2} \ \vert \ r_{i}.x = r_{j}.x \ and \ \vert D_{1} \vert < \vert D_{2} \vert$.

% ----------------------------------- DEFINITION 7 REQUIREMENTS EQUIVALENCE --------------------------------- %
\bigskip
\noindent \textbf{Definition 7 (\textsl{User requirements equivalence})}.
A set of \textsl{user requirements} $R_{1}$ is equivalent to a set of \textsl{user requirements} $R_{2}$, represented by $R_{1} \cong R_{2}$, iff: $\forall r_{i} \in R_{1}, \ \exists r_{j} \in R_{2} \ \vert \ eval (r_{i}) = eval(r_{j}) \ and \ \vert R_{1} \vert = \vert R_{2} \vert$.

% ----------------------------------- DEFINITION 8 REQUIREMENTS MORE RESTRICT --------------------------------- %
\bigskip
\noindent \textbf{Definition 8 (\textsl{User requirements more restrict})}.
Given a set of \textsl{user requirements} $R_{1}$ and $R_{2}$, $R_{1}$ is more restrict than $R_{2}$, represented by $R_{1} \ \rhd \ R_{2}$, iff:
\begin{flushleft}
Case 1: $\forall r_{i} \in R_{1}, \ \exists r_{j} \in R_{2} \ \vert \ eval (r_{i}) \subset eval(r_{j}) \ and \ \vert R_{1} \vert = \vert R_{2} \vert$.
\end{flushleft}
\begin{flushleft}
Case 2: $\forall D_{m} \in R_{1}, \ \exists D_{n} \in R_{2} \ \vert \ D_{n} \subset D_{m}$. \\
\end{flushleft}

% ----------------------------------- DEFINITION 9 REQUIREMENTS LESS RESTRICT --------------------------------- %
\bigskip
\noindent \textbf{Definition 9 (\textsl{User requirements less restrict})}.
Given a set of \textsl{user requirements} $R_{1}$ and $R_{2}$, $R_{1}$ is less restrict than $R_{2}$, represented by $R_{1} \ \lhd \ R_{2}$, iff:
\begin{flushleft}
Case 1: $\forall r_{i} \in R_{1}, \ \exists r_{j} \in R_{2} \ \vert \ eval (r_{i}) \supset eval(r_{j}) \ and \ \vert R_{1} \vert = \vert R_{2} \vert$.
\end{flushleft}
\begin{flushleft}
Case 2: $\forall D_{m} \in R_{1}, \ \exists D_{n} \in R_{2} \ \vert \ D_{m} \subset D_{n}$. \\
\end{flushleft}

% ----------------------------------- DEFINITION 10 PART MORE / LESS RESTRICT --------------------------------- %
\bigskip
\noindent \textbf{Definition 10 (\textsl{Part of the user requirements more restrict and part less restrict})}.
Given a set of \textsl{user requirements} $R_{1}$ and $R_{2}$, part of the \textsl{user requirements} $R_{1}$ can be more restrict and part less restrict than the \textsl{user requirements} $R_{2}$, represented by $R_{1} \ \diamond \ R_{2}$, iff:
\begin{flushleft}
$\forall r_{i} \in R_{1}, \ \exists r_{j} \in R_{2} \ \vert \ (eval (r_{i}) \subset eval(r_{j}) \ or \ eval (r_{i}) \supset eval(r_{j})) \ and \ \vert R_{1} \vert = \vert R_{2} \vert$.
\end{flushleft}

% ----------------------------------- DEFINITION 11 REQUIREMENTS COMPLETELY DIFFERENT --------------------------------- %
\bigskip
\noindent \textbf{Definition 11 (\textsl{User requirements different})}.
Given a set of \textsl{user requirements} $R_{1}$ and $R_{2}$, $R_{1}$ is different of $R_{2}$, represented by $R_{1} \ \neq \ R_{2}$, iff:
\begin{flushleft}
$\forall r_{i} \in R_{1}, \ \nexists r_{j} \in R_{2} \ \vert \ r_{i}.x = r_{j}.x$.
\end{flushleft}

% ----------------------------------- DEFINITION 7 QUERY EQUIVALENCE  --------------------------------- %
\bigskip
\noindent \textbf{Definition 7 (\textsl{Query equivalence})}.
Definition 2 (query equivalence): a query Q1 is equivalent to a query Q2 if: 
Q1 and Q2 have the same number of abstract services
For each abstract services in Q1 there is an equivalent in Q2

% ----------------------------------- DEFINITION 8 QUERY SUBSET  --------------------------------- %
\bigskip
\noindent \textbf{Definition 8 (\textsl{Query subset})}.
Definition 10 (query subset): a query Q1 is a subset of the query Q2 if: 
Q1 has less abstract services than Q2
For each abstract service in Q1 there is an equivalent in Q2.
In other words, the query Q1 is contained in the query Q2.

% ----------------------------------- DEFINITION 9 QUERY ??  --------------------------------- %
\bigskip
\noindent \textbf{Definition 9 (\textsl{different queries but with some abstract services in common})}.
Definition 11 (different queries but with some abstract services in common): this case occurs when given a query Q1 and a query Q2: 
Q1 and Q2 have a different number of abstract services
There is at least one abstract service in Q1 that has an equivalent in Q2;
There is at least one abstract service in Q1 that has no equivalent in Q2; and
There is at least one abstract service in Q2 that has no equivalent in Q1;
