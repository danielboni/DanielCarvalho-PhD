The input for the \textit{Rhone} algorithm is: (1) a query; (2) a list of concrete services.

\noindent \textbf{Definition 1 (Query):}
A query $Q$ is defined as a set of \textit{abstract services}, a set of \textit{constraints}, and a set of \textit{user preferences} in accordance with the grammar: 

\begin{center}

\begin{math}
Q (\overline{I}_{h}; \overline{O}_{h}) := A_{1}(\overline{I}_{1l}; \overline{O}_{1l}), A_{2}(\overline{I}_{2l}; \overline{O}_{2l}), ..,  A_{n}(\overline{I}_{nl}; \overline{O}_{nl}),C_{1},C_{2}, .., C_{m}[P_{1},P_{2}, .., P_{k}]
\end{math}

\end{center}

The left-hand of the definition is called the \textit{head} of the query; and the right-hand is called the \textit{body}. 
%
$\overline{I}$ and $\overline{O}$ are a set of comma-separated \textit{input} and \textit{output} parameters, respectively.
%
There are two types of parameters: the ones who appears in the \textit{head} definition called \textit{head} variables, and the ones who appears only in the \textit{body} definition called \textit{local} variables.
%
The sets $\overline{I}_{h}$ and $\overline{O}_{h}$ refer to \textit{head} input and output variables, 
and the sets $\overline{I}_{l}$ and $\overline{O}_{l}$ refer to \textit{local} input and output variables.
Intuitively, $\overline{I}$ is the union of $\overline{I}_{h}$ and all $\overline{I}_{l}$ such as  
$\overline{I}$ =  $\overline{I}_{h} \cup \lbrace\overline{I}_{1l},..,\overline{I}_{nl}\rbrace$. 
The same rule can be applied to output variables: $\overline{O}$ =  $\overline{O}_{h} \cup \lbrace\overline{O}_{1l},..,\overline{O}_{nl}\rbrace$.
% 
\textit{Abstract services} ($A_{1}, A_{2}, .., A_{n}$) describes a set of basic service capabilities.
%
$C_{1}, C_{2}, .., C_{m}$ are \textit{constraints} over the \textit{input} and/or \textit{output} parameters.
The \textit{user preferences} (over the services) are specified in $P_{1}, P_{2}, .., P_{k}$. 
%
$C_{i}$ and $P_{j}$ are in the form $x \otimes c$, where $x$ is a identifier; $c$ is a constant; and
$\otimes \in\lbrace \geq, \leq, =, \neq, <, >\rbrace$.

\noindent \textbf{Definition 2 (Concrete service):} A concrete service ($S$) is defined as a set of 
\textit{abstract services}, and by its \textit{quality constraints} according to the grammar:

\begin{center}

\begin{math}
S (\overline{I}_{h}; \overline{O}_{h}) := A_{1}(\overline{I}_{1l}; \overline{O}_{1l}), A_{2}(\overline{I}_{2l}; \overline{O}_{2l}), ..,  A_{n}(\overline{I}_{nl}; \overline{O}_{nl})[Q_{1},Q_{2}, .., Q_{k}]
\end{math}

\end{center} 

A concrete service ($S$) is defined as a set of abstract services ($A$), and by its quality constraints $P$. 
These quality constraints associated to the service represent the service level agreement exported by the concrete service. \textcolor{red}{Specify the sla measures. Are they variable? constants? Special class of identifiers associated to the services?}



Given the query and a list of concrete services as input, the algorithm looks for candidate concrete services. 
Candidate concrete service is a concrete service that probably can be used in the rewriting process. 
It contains only abstract services which are also query abstract services, and with the same signature (same name and number of input/output variables).
The candidate concrete services are chosen while searching for matches between abstract services in $S$ and abstract service in $Q$. 
%The following definitions will guide us while selecting candidate concrete services.

\noindent \textbf{Definition 3 (abstract service equivalence \textcolor{red}{matching??}):} 
A match between abstract services occurs when an abstract service $A_{i}$ can be matched to $A_{j}$, denoted $A_{i} \equiv A_{j}$ \textcolor{red}{according to the following conditions...}. 
Given two abstract services $A_{i}$ and $A_{j}$, $A_{i}$ = $A_{j}$ iff: (1) $A_{i}$ and $A_{j}$ have the same abstract function name; (2) the number of \textit{input} parameters of $A_{i}$ is equal to $A_{j}$; and (3) the number of \textit{output} parameters of $A_{i}$ is equal to $A_{j}$. 


%\noindent \textbf{Definition 3 (Abstract service equivalence):} Given a query $Q$; a concrete service $S$; and an abstract service $A_{i}$ such that $A_{i} \in Q$ and $A_{i} \in S$, $A_{i}.Q$ is equivalent to $A_{i}.S$, denoted $A_{i}.Q = A_{i}.S$, iff the number of variables of $A_{i} \in Q$ is equal to the number of variables of $A_{i}.S$.

%Once a matching between abstract services is found, the algorithm checks if the concrete service associated in the matching is a candidate to be part of the rewriting process.

Based on the assumptions that: (a) a concrete service can represent a service composition in which the abstract services involved may be able not only to retrieve data, but also to execute business rules that may impact the entire system; and (b) the execution\textcolor{red}{(semantics)} of a concrete service is defined by the combined semantics of all its abstract services.  
A concrete service (S) is selected as \textit{candidate} to the rewriting process if for each abstract service in $S$ there is an equivalent \textcolor{red}{match?} in $Q$; there is no abstract service in $S$ that does not exist in $Q$; and the quality constrains in $Q$ must be guaranteed in $S$.

\noindent \textbf{Definition 4 (candidate service):} Given a query $Q$ and a concrete service $S$, $S$ is a \textit{candidate} service iff: (1) $\nexists A_{i} \ s.t. \ A_{i} \in S \ and \ A_{i} \not\in Q$; and (2) the quality constraints in $S$ does not violate the user preferences in $Q$. 



%An important concept in our approach is the \textit{candidate service description} (CSD). 
A \textit{candidate service description} (CSD) describes how a \textit{candidate} concrete service can be used in the query rewriting process.
It is a complex data structure which includes: mappings from variables in a concrete service to variables in the query; 
mappings from variables on the head of a concrete service to variables on its body;
a set of abstract services that represents partially or fully the abstract services in the query; and 
a set of quality constrains associated to the concrete service.
Intuitively, a rewriting is a set of \textit{candidate service descriptions} that fully covers the original query, and do not violates the user preferences.

\noindent \textbf{Definition 5 (candidate service description):} A CSD is represented by an n-tuple: %follows: 
\begin{center}
$\langle S, h, \varphi, G, P\rangle$
\end{center}
where $S$ is a concrete service. 
\textit{h} are mappings between variables in the head of $S$ to variables in the body of $S$. 
$\varphi$ are mapping between variables in the concrete service to variables in the query.
$G$ is a set of abstract services covered by $S$. 
$P$ is a set quality constraints associated to the service $S$. 

The CSD for a given service will be created following rules: (1) for all head variables in $S$, there is a mapping for a head variable in $Q$; and (2) if $x$ is an local variable in $S$ mapped to a local variable in $Q$, then $S$ must cover all abstract services in $Q$ which uses $x$ or cover only one abstract service that uses $x$.
