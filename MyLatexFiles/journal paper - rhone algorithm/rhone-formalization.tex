The input for the \textit{Rhone} algorithm is: (1) a query; (2) a list of concrete services.

\noindent \textbf{Definition 1 (Query):}
A query $Q$ is defined as a set of \textit{abstract services}, a set of \textit{constraints}, and a set of \textit{user preferences} in accordance with the grammar: 

\begin{center}

\begin{math}
Q (\overline{I}_{h}; \overline{O}_{h}) := A_{1}(\overline{I}_{1l}; \overline{O}_{1l}), A_{2}(\overline{I}_{2l}; \overline{O}_{2l}), ..,  A_{n}(\overline{I}_{nl}; \overline{O}_{nl}),C_{1},C_{2}, .., C_{m}[P_{1},P_{2}, .., P_{k}]
\end{math}

\end{center}

The left-hand of the definition is called the \textit{head} of the query; and the right-hand is called the \textit{body}. 
%
$\overline{I}$ and $\overline{O}$ are a set of comma-separated \textit{input} and \textit{output} parameters, respectively.
%
There are two types of parameters: the ones who appears in the \textit{head} definition called \textit{head} variables, and the ones who appears only in the \textit{body} definition called \textit{local} variables.
%
The sets $\overline{I}_{h}$ and $\overline{O}_{h}$ refer to \textit{head} input and output variables, 
and the sets $\overline{I}_{l}$ and $\overline{O}_{l}$ refer to \textit{local} input and output variables.
Intuitively, $\overline{I}$ is the union of $\overline{I}_{h}$ and all $\overline{I}_{l}$ such as  
$\overline{I}$ =  $\overline{I}_{h} \cup \lbrace\overline{I}_{1l},..,\overline{I}_{nl}\rbrace$. 
The same rule can be applied to output variables: $\overline{O}$ =  $\overline{O}_{h} \cup \lbrace\overline{O}_{1l},..,\overline{O}_{nl}\rbrace$.
% 
\textit{Abstract services} ($A_{1}, A_{2}, .., A_{n}$) describes a set of basic service capabilities.
%
$C_{1}, C_{2}, .., C_{m}$ are \textit{constraints} over the \textit{input} and/or \textit{output} parameters.
The \textit{user preferences} (over the services) are specified in $P_{1}, P_{2}, .., P_{k}$. 
%
$C_{i}$ and $P_{j}$ are in the form $x \otimes c$, where $x$ is a identifier; $c$ is a constant; and
$\otimes \in\lbrace \geq, \leq, =, \neq, <, >\rbrace$.

\noindent \textbf{Definition 2 (Concrete service):} A concrete service ($S$) is defined as a set of 
\textit{abstract services}, and by its \textit{quality constraints} according to the grammar:

\begin{center}

\begin{math}
S (\overline{I}_{h}; \overline{O}_{h}) := A_{1}(\overline{I}_{1l}; \overline{O}_{1l}), A_{2}(\overline{I}_{2l}; \overline{O}_{2l}), ..,  A_{n}(\overline{I}_{nl}; \overline{O}_{nl})[Q_{1},Q_{2}, .., Q_{k}]
\end{math}

\end{center} 

A \textit{concrete service} definition is similar to the \textit{query} definition, excepting the fact that a \textit{concrete service} does not have constraints over input and output variables.
The input variables $\overline{I}$ is the union of $\overline{I}_{h}$ (\textit{head} variables) and all $\overline{I}_{l}$ (\textit{local} variables) such as  
$\overline{I}$ =  $\overline{I}_{h} \cup \lbrace\overline{I}_{1l},..,\overline{I}_{nl}\rbrace$, and 
the output variables $\overline{O}$ = $\overline{O}_{h} \cup \lbrace\overline{O}_{1l},..,\overline{O}_{nl}\rbrace$.
$Q_{1},Q_{2}, .., Q_{k}$ are \textit{quality measures} associated to the concrete service. 
These \textit{measures} reflect the quality aspects present in the service level agreement exported by the concrete service. 
$Q_{i}$ is in the form $x \otimes c$, where $x$ is a special class of identifiers associated to the services; $c$ is a constant; and $\otimes \in\lbrace \geq, \leq, =, \neq, <, >\rbrace$.
 
While selecting services, the algorithm deals with three matching problems: \textit{measures} matching, \textit{abstract service} matching and \textit{concrete service} matching.

\noindent \textbf{Definition 3 (\textit{measures} matching):} 
Given a \textit{user preference} $P_{i}$ and a quality measure $Q_{j}$, a matching between them can be made if:
(\textit{i}) the identifier $c_{i}$ in $P_{i}$ has the same name of $c_{j}$ in $Q_{j}$; and
(\textit{ii}) the evaluation of $Q_{j}$, denoted $eval(Q_{j})$, must satisfy the evaluation of $P_{i}$ ($eval(P_{i})$). In other words, $eval(Q_{j}) \subset eval(P_{i})$.

\noindent \textbf{Definition 4 (\textit{abstract service} matching):} 
Given two abstract services $A_{i}$ and $A_{j}$, a match between \textit{abstract services} occurs when an \textit{abstract service} $A_{i}$ can be matched to $A_{j}$, denoted $A_{i} \equiv A_{j}$, according to the following conditions: 
(\textit{i}) $A_{i}$ and $A_{j}$ must have the same abstract function name; 
(\textit{ii}) the number of input variables of $A_{i}$, denoted $vars_{input}(A_{i})$, is equal or higher than the number of input variables of $A_{j}$ ($vars_{input}(A_{j})$); and 
(\textit{iii}) the number of output variables of $A_{i}$, denoted $vars_{output}(A_{i})$, is equal or higher than the number of output variables of $A_{j}$ ($vars_{output}(A_{j})$).

\noindent \textbf{Definition 5 (\textit{Concrete service} matching):} 
A \textit{concrete service} $S$ can be matched with the \textit{query} $Q$ according to the following conditions:
(\textit{i}) $\forall A_{i}  \ s. \ t. \lbrace\ A_{i} \in \ S\rbrace, \ \exists \ A_{j} \ $ $s. \ t. \lbrace\ A_{j} \in \ Q\rbrace, \ where \ A_{i} \equiv A_{j}.$ For all \textit{abstract services} $A_{i}$ in $S$, there is one \textit{abstract service} $A_{j}$ in $Q$ that satisfies the \textit{abstract service} matching problem (Definition 4); and
(\textit{ii}) . For all \textit{single measure} $P_{i}$ in $Q$, there is one \textit{single measure} $Q_{i}$ in $S$ that satisfies the \textit{measures} matching problem (Definition 3).

For the \textit{candidate concrete services} selected regarding the matching problems, the algorithm creates mappings from these services to the \textit{query}.
A \textit{candidate service description} (CSD) describes how a \textit{candidate concrete service} can be used in the \textit{query} rewriting process.

\noindent \textbf{Definition 6 (candidate service description):} A CSD is represented by an n-tuple:
\begin{center}
$\langle S, h, \varphi, G, P\rangle$
\end{center}
where $S$ is a \textit{concrete service}. 
\textit{h} are mappings between variables in the \textit{head} of $S$ to variables in the \textit{body} of $S$. 
$\varphi$ are mapping between variables in the \textit{concrete service} to variables in the \textit{query}.
$G$ is a set of \textit{abstract services} covered by $S$. 
$P$ is a set \textit{quality measures} associated to the service $S$. 

A CSD is created according to variable mapping rules mainly based on 2 criterias: the type and the dependency (variables used as inputs on other \textit{abstract services}). 
\begin{description}
\item \textit{Rule 1}: \textit{Head} variables in \textit{concrete services} can be mapped to \textit{head} or \textit{local} variables in the \textit{query}.
\item \textit{Rule 2}: \textit{Local} variables in \textit{concrete services} can be mapped to \textit{head} variables in the \textit{query}.
\item \textit{Rule 3}: \textit{Local} variables in \textit{concrete services} can be mapped to \textit{local}
 variables in the \textit{query} if the \textit{concrete service} covers all \textit{abstract services} in the \textit{query} that depend on this variable. The relation ``depends''  means that this \textit{local} variable is used as input in another \textit{abstract service}. 
\end{description}