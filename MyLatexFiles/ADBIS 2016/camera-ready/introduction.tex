Current data integration implies consuming data from different data services and
integrating the results according to different quality requirements related to
data cost, provenance, privacy, reliability, availability, among others. Data
services and data processing services can take advantage from the on-demand and
\textit{pay-as-you-go} model offered by the cloud architecture. The quality
conditions and penalties under which these services are delivered can be defined in
contracts using Service Level Agreements (SLA).        

Cloud services (data services, data processing services, for instance) and the
cloud provider export their SLA specifying the level of services the user can
expect from them. A user willing to integrate data establishes a contract with
the cloud provider guided by an economic model that defines the services he/she can
access, the conditions in which they can be accessed (duplication, geographical
location) and their associated cost. Thus, for a given requirement, cloud services 
(from one or several cloud providers) are chosen to 
retrieve, process and integrate data according to the type of contracts
he/she established with them.         

In this context, data integration deals with a matching problem of the user's
integration preferences which includes quality constraints and data
requirements, and his/her specific cloud subscription with the SLA's provided by
cloud services. Matching SLAs can imply dealing with heterogeneous SLA
specifications and SLA-preferences incompatibilities. Moreover, even with
the possibility of having an unlimited access to cloud resources, the user is
limited to the resources and to the budget agreed by his/her cloud subscription. 
Inspired by these problems and carrying on the ideas presented in our previous work~\cite{Bennani2014},
the aim of this paper is to introduce our service-based query rewriting algorithm guided by user 
preferences and SLAs which enhances the quality on the results integration in a multi-cloud context. 
          
This paper is organized as follows. 
Section~\ref{sec:relatedwork} discusses related works. 
Section~\ref{sec:rhone} describes the \textit{Rhone} algorithm and its formalization. Experiments and results are described in the section~\ref{sec:experiments}. 
Finally, section~\ref{sec:conclusion} concludes the paper and discusses future works.