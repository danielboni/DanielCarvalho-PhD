
%
The input for the \textit{Rhone} algorithm is: (1) a query; (2) a list of concrete services.

\noindent \textbf{Definition 1 (Query):}
A query $Q$ is defined as a set of \textit{abstract services}, a set of \textit{constraints}, and a set of \textit{user preferences} in accordance with the grammar: 

\begin{center}
\small
\begin{math}
Q (\overline{I}_{h}; \overline{O}_{h}) := A_{1}(\overline{I}_{1l}; \overline{O}_{1l}), A_{2}(\overline{I}_{2l}; \overline{O}_{2l}), ..,  A_{n}(\overline{I}_{nl}; \overline{O}_{nl}),C_{1},C_{2}, .., C_{m}[P_{1},P_{2}, .., P_{k}]
\end{math}
\end{center}
%
The left-hand of the definition is called the \textit{head} of the query; and the right-hand is called the \textit{body}. 
%
$\overline{I}$ and $\overline{O}$ are a set of comma-separated \textit{input} and \textit{output} parameters, respectively.
%
There are two types of parameters: the ones who appears in the \textit{head} definition called \textit{head} variables, and the ones who appears only in the \textit{body} definition called \textit{local} variables.
%
The sets $\overline{I}_{h}$ and $\overline{O}_{h}$ refer to \textit{head} input and output variables, 
and the sets $\overline{I}_{l}$ and $\overline{O}_{l}$ refer to \textit{local} input and output variables.
Intuitively, $\overline{I}$ is the union of $\overline{I}_{h}$ and all $\overline{I}_{l}$ such as  
$\overline{I}$ =  $\overline{I}_{h} \cup \lbrace\overline{I}_{1l},..,\overline{I}_{nl}\rbrace$. 
Also, the intersection $\overline{I}_{h} \cap \overline{I}_{1l} \cap \overline{I}_{2l},.., \cap \overline{I}_{nl}$ is not empty which means that: (1) there are \textit{head} variable that are used on the \textit{abstract services} in the body definition; and (2) there are \textit{local variables} that are shared among the \textit{abstract services}. 
The same rule can be applied to output variables: $\overline{O}$ =  $\overline{O}_{h} \cup \lbrace\overline{O}_{1l},..,\overline{O}_{nl}\rbrace$, and the intersection among $\overline{O}_{h}$ and all $\overline{O}_{l}$ is not empty.
% 
\textit{Abstract services} ($A_{1}, A_{2}, .., A_{n}$) describes a set of basic service capabilities.
%
$C_{1}, C_{2}, .., C_{m}$ are \textit{constraints} over the \textit{input} and/or \textit{output} parameters. These constraints are used while querying the databases. 
The \textit{user preferences} (over the services) are specified in $P_{1}, P_{2}, .., P_{k}$.  
%
$C_{i}$ and $P_{j}$ are in the form $x \otimes c$, where $x$ is a identifier; $c$ is a constant; and
$\otimes \in\lbrace \geq, \leq, =, \neq, <, >\rbrace$.

\noindent \textbf{Definition 2 (Concrete service):} A concrete service ($S$) is defined as a set of 
\textit{abstract services}, and by its \textit{quality measures} according to the grammar:

\begin{center}

\begin{math}
S (\overline{I}_{h}; \overline{O}_{h}) := A_{1}(\overline{I}_{1l}; \overline{O}_{1l}), A_{2}(\overline{I}_{2l}; \overline{O}_{2l}), ..,  A_{f}(\overline{I}_{fl}; \overline{O}_{fl})[M_{1},M_{2}, ..,M_{g}]
\end{math}

\end{center} 

A \textit{concrete service} definition is similar to the \textit{query} definition, excepting the fact that a \textit{concrete service} does not have constraints over input and output variables.
The input variables $\overline{I}$ is the union of $\overline{I}_{h}$ (\textit{head} variables) and all $\overline{I}_{l}$ (\textit{local} variables) such as  
$\overline{I}$ =  $\overline{I}_{h} \cup \lbrace\overline{I}_{1l},..,\overline{I}_{nl}\rbrace$, and
the intersection $\overline{I}_{h} \cap \overline{I}_{1l} \cap \overline{I}_{2l},.., \cap \overline{I}_{fl}$ is not empty, meaning that there are \textit{head} and \textit{local }variables being shared among the \textit{abstract services}. 
The same rules are applied to output variables $\overline{O}$ = $\overline{O}_{h} \cup \lbrace\overline{O}_{1l},..,\overline{O}_{nl}\rbrace$, and $\overline{O}_{h} \cap \overline{O}_{1l} \cap \overline{O}_{2l},.., \cap  \overline{O}_{fl}$ is not empty.
%
$M_{1},M_{2}, .., M_{g}$ are \textit{quality measures} associated to the concrete service. 
These \textit{measures} reflect the quality aspects present in the service level agreement exported by the concrete service. 
%
In this algorithm, we are assuming that there is a previous phase in our approach which allow us to extract the \textit{quality measures} associated to concrete services from SLAs, and generate the expected input data according to the grammar.
%
$M_{i}$ is in the form $x \otimes c$, where $x$ is a special class of identifiers associated to the services; $c$ is a constant; and $\otimes \in\lbrace \geq, \leq, =, \neq, <, >\rbrace$.
 
\bigskip
\noindent \textit{Example 1 (query and concrete service):} To illustrate the definition above let us suppose an example based on the scenario. 
\textit{A user wants to retrieve patients DNA information that were infected by the disease ``flu'', using services with availability higher than 98\%, price per call less than 0.2\$ and total cost less than 2\$.}
The query can be expressed using the grammar as follows. The decorations $?$ and $!$ differentiate input from output parameters, respectively. 
\begin{center}
$Q(d?; dna!) := diseaseInfectedPatients(d?; p!), DNAinformation(p?; dna!),$
\\
$d = ``flu'' [availability > 98\%, \ price \ per \ call < 0.2\$, \ total \ cost < 2\$]$
\end{center}
The query $Q$ has an input parameter $d$ and an output parameter $dna$. 
These \textit{head} variable are used in the \textit{abstract services} $diseaseInfectedPatients$ and $DNAinformation$. 
The local variable $p$ is an output in $diseaseInfectedPatients$ and it is used as input in $DNAinformation$.
The constraint $d = ``flu''$ will be used while querying the databases in the \textit{where clause}.
Between brackets there are \textit{user preferences}: $availability$, $price \ per \ call$ and $total \ cost$.
Two concrete services are exemplified as following. 
\begin{center}
\small
$S1(d?; p!) := diseaseInfectedPatients(d?; p!)[availability > 99\%, \ price \ per \ call < 0.1\$]$ 
\\
$S2(p?; dna!) := DNAinformation(d?; dna!)[availability > 98\%, \ price \ per \ call < 0.1\$]$
\end{center}
$S1$ and $S2$ are two different concrete services. $S1$ receives as input a disease $d$ and return as output the patients $p$ that were infected by $d$. 
$S2$ receives a patient $p$ and returns the dna information $dna$. In both cases, their \textit{quality measures} are defined between the brackets. Highlighting that these measures are extract in a previous phase of our approach that is not the focus in this paper. In the next lines we will describe the Rhone algorithm in detail.
 
While selecting services, the algorithm deals with three matching problems: \textit{measures} matching, \textit{abstract service} matching and \textit{concrete service} matching.

\noindent \textbf{Definition 3 (\textit{measures} matching):} 
Given a \textit{user preference} $P_{i}$ and a quality measure $Q_{j}$, a matching between them can be made if:
(\textit{i}) the identifier $c_{i}$ in $P_{i}$ has the same name of $c_{j}$ in $Q_{j}$; and
(\textit{ii}) the evaluation of $Q_{j}$, denoted $eval(Q_{j})$, must satisfy the evaluation of $P_{i}$ ($eval(P_{i})$). In other words, $eval(Q_{j}) \subset eval(P_{i})$.

\noindent \textbf{Definition 4 (\textit{abstract service} matching):} 
Given two abstract services $A_{i}$ and $A_{j}$, a match between \textit{abstract services} occurs when an \textit{abstract service} $A_{i}$ can be matched to $A_{j}$, denoted $A_{i} \equiv A_{j}$, according to the following conditions: 
(\textit{i}) $A_{i}$ and $A_{j}$ must have the same abstract function name; 
(\textit{ii}) the number of input variables of $A_{i}$, denoted $vars_{input}(A_{i})$, is equal or higher than the number of input variables of $A_{j}$ ($vars_{input}(A_{j})$); and 
(\textit{iii}) the number of output variables of $A_{i}$, denoted $vars_{output}(A_{i})$, is equal or higher than the number of output variables of $A_{j}$ ($vars_{output}(A_{j})$).

\noindent \textbf{Definition 5 (\textit{Concrete service} matching):} 
A \textit{concrete service} $S$ can be matched with the \textit{query} $Q$ according to the following conditions:
(\textit{i}) $\forall A_{i}  \ s. \ t. \lbrace\ A_{i} \in \ S\rbrace, \ \exists \ A_{j} \ $ $s. \ t. \lbrace\ A_{j} \in \ Q\rbrace, \ where \ A_{i} \equiv A_{j}.$ For all \textit{abstract services} $A_{i}$ in $S$, there is one \textit{abstract service} $A_{j}$ in $Q$ that satisfies the \textit{abstract service} matching problem (Definition 4); and
(\textit{ii}) . For all \textit{single measure} $P_{i}$ in $Q$, there is one \textit{single measure} $Q_{i}$ in $S$ that satisfies the \textit{measures} matching problem (Definition 3).

For the \textit{candidate concrete services} selected regarding the matching problems, the algorithm creates mappings from these services to the \textit{query}.
A \textit{candidate service description} (CSD) describes how a \textit{candidate concrete service} can be used in the \textit{query} rewriting process.

\noindent \textbf{Definition 6 (candidate service description):} A CSD is represented by an n-tuple:
\begin{center}
$\langle S, h, \varphi, G, P\rangle$
\end{center}
where $S$ is a \textit{concrete service}. 
\textit{h} are mappings between variables in the \textit{head} of $S$ to variables in the \textit{body} of $S$. 
$\varphi$ are mapping between variables in the \textit{concrete service} to variables in the \textit{query}.
$G$ is a set of \textit{abstract services} covered by $S$. 
$P$ is a set \textit{quality measures} associated to the service $S$. 

A CSD is created according to variable mapping rules mainly based on 2 criterias: the type and the dependency (variables used as inputs on other \textit{abstract services}). 
\begin{description}
\item \textit{Rule 1}: \textit{Head} variables in \textit{concrete services} can be mapped to \textit{head} or \textit{local} variables in the \textit{query}.
\item \textit{Rule 2}: \textit{Local} variables in \textit{concrete services} can be mapped to \textit{head} variables in the \textit{query}.
\item \textit{Rule 3}: \textit{Local} variables in \textit{concrete services} can be mapped to \textit{local}
 variables in the \textit{query} if the \textit{concrete service} covers all \textit{abstract services} in the \textit{query} that depend on this variable. The relation ``depends''  means that this \textit{local} variable is used as input in another \textit{abstract service}. 
\end{description}