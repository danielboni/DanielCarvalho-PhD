%This section introduces our new vision of data integration, proposes our approach and briefly presents our query rewriting algorithm guided by user preferences and SLAs.

%\subsection{New vision of Data Integration}
%In our work, we consider a new vision of data integration in a multi-cloud context (see figure~\ref{fig:scenario}).
The metamodel in the figure~\ref{fig:scenario} illustrates our new vision of data integration. 
The \textsl{Multi-Cloud} is configured as a set of \textsl{Cloud Infrastructures}. \textsl{Data producers} and \textsl{data consumers} subscribe to \textsl{cloud infrastructures}. 
Their subscription credentials are illustrated thanks to a \textsl{SLA} (\textsl{Consumer SLA} or \textsl{Producer SLA}) defining what the \textsl{cloud infrastructure} offers to them through their subscription. 
\textsl{Data} are provided and consumed by \textsl{Data Producers} and \textsl{Data Consumers}, respectively. \textsl{Data consumers} willing to process an \textsl{Integration} defines a \textsl{Query} according to his/her needs. 
%The \textsl{Integration} process has an associated \textsl{SLA} (\textsl{Integration SLA}) which matches requirements and constraints from \textsl{Data Consumers}, \textsl{Data Producers} and	\textsl{Data} itself. 
%
Then, the \textsl{integration process} is triggered selecting \textsl{data consumers} deployed on the \textsl{multi-cloud} considering the \textsl{query} and its \textsl{producer SLA}. Moreover, the process deals also with consumer SLA in order to verify if the consumer has access to the selected producer and if he/she has enough resources for processing the \textsl{data producer}'s service. In addition, the \textsl{integration process} can also deal with \textsl{integration SLAs} verifying whether there is a previous integration request that can be reused for the actual integration.
The \textsl{integration process} proposes an \textsl{integration plan} that retrieves data and integrate the \textsl{results}. These results are finally delivered to the consumer according to his/her requirements and constraints. When the integration is done, a new \textsl{integration SLA} is created to the last integration including all information about query, consumer requirements and constrains, selected data producers, integration plan, integration time and performance execution.
%Thus, integrating data implies a multi-dimensional matching of the different types of \textsl{SLA}.

\begin{figure}[th!]
\center
\includegraphics[scale=0.70]{metamodel.pdf}
\caption{Data integration metamodel}\label{fig:scenario}
\end{figure}

%\begin{figure*}[th!]
%\center
%\includegraphics[scale=0.50]{Cloud_SLA.pdf}
%\caption{Cloud SLA model}\label{fig:cloudsla}
%\end{figure*}

Therefore, given a \textsl{Data Consumer} query, his/her quality requirements and cloud subscription, the query is rewritten in terms of \textsl{Data Producers} that fulfill the integration requirements and constraints (associated to \textsl{Data Consumers}, \textsl{Data Producers} and \textsl{Data}), and deliver the expected results. This new vision brings challenges to data integration, such as: (i) \underline{Performance issues}. Given the huge amount of \textsl{Data Providers} in the \textsl{Multi-Cloud}, the \textsl{Integration} can require a huge amount of cloud resources and processing time; (ii) \underline{Economic model}. Even with the on-demand and pay-per-use imposed by the cloud, users are limited to the resources they have contracted and to the budget they are ready to pay for while asking for a integration. %\underline{Economic model}. The cloud provides resources in an on-demand and pay-per-use way to cloud consumers. However they are limited to the resources they have contracted and to the budget they are ready to pay for. 
%Thus, it is crucial to design new methods for data integration adapted to this new context; 
(iii) \underline{Quality issues}. Some rewritings produced and executed to the query could not satisfy his/her quality requirements concerning privacy, data provenance, cost, among others. Consequently, users may become dissatisfied with the obtained results; (iv) \underline{SLA heterogeneity}. In the multi-cloud, \textsl{Data Consumers} and \textsl{Data Producers} export their \textsl{SLAs} with different semantics and structure making the matching of integration requirements  and constraints more challenging. Moreover, while integrating services, we can also face incompatibilities of SLAs such as measures with the same meaning but with different names, measures with the same name but with different associated values and units, among others; and (iv) \underline{Reuse}. Rewriting and executing the \textsl{Query} is computationally costly in terms of processing time and economic cost. Thus, it is necessary to propose a manner of reusing previous integration in order to save time and money, but also meeting the user expectations.
%\bigskip

Motivated by these challenges, we propose a SLA-based data integration approach adapted to the multi-cloud which includes: (i) looking for \textsl{Data Producers}; (ii) \textsl{Data} retrieval and integration; and (iii) delivering results to the user considering their characteristics and constraints.  In this sense, our approach is divided in four steps:
% as illustrated in the figure~\ref{fig:generalapproach}. 
%\begin{figure}[h!]
%\centering
%\includegraphics[scale=0.33]{workflow-approach.pdf}
%\caption{SLA-based data integration workflow.}
%\label{fig:generalapproach}
%\end{figure}

Given a user \textit{query}, a set of associated user \textit{preferences} and \textsl{Data Consumers}:
\\
\textbf{\underline{SLA derivation}}. In this step, we compute what we call an \textsl{integration SLA} that matches user' integration requirements (including quality constraints and data requirements) with the \textsl{SLA}'s provided by \textsl{data producers}, given a specific user cloud subscription. The user may have general requirements depending on the context he/she wants to integrate his/her data such as economic cost, bandwidth limit, free services, and storage and processing limits. The \textit{SLA derivation} is the big challenge while dealing with SLAs and particularly for adding quality dimensions to data integration. Furthermore, the \textsl{integration SLA} guides the query evaluation, and the way results are computed and delivered. \\
\textbf{\underline{Filtering data services}}. The \textsl{integration SLA} is used (i)
to filter previous \textsl{integration SLA} derived for a similar request in order to reuse results; or (ii) to filter possible \textsl{data producers} that can be used for answering the query. \\ %The SLA exported by a selected \textit{cloud service} should satisfy the user \textit{preferences}. \\
\textbf{\underline{Query rewriting}}. Given a set of \textit{data producers} that can
potentially provide data for integrating the query result, a set of service compositions is generated according to the \textsl{integration SLA} and the agreed \textsl{Producer SLA} of each \textsl{data producer}. \\
\textbf{\underline{Integrating a query result}}. The service compositions are
executed with services from one or several clouds where the user has a
subscription.
The execution cost of service compositions must fulfill the \textsl{integration
SLA}. The clouds resources needed by the user to execute the composition and how
to use them is decided taking in consideration the economic cost determined by
the data to be transferred, the number of external calls to services, data storage and delivery cost.

%The algorithm 1 describes in general lines our approach which integrate data
%from multi-cloud environments considering quality aspects.
%%
%As input, we consider (1) a user query $Q$; (2) a set of user preferences $P$;
%(3) a user cloud subscription $C$; (4) a set of previous \textit{integrated SLA}
%$\bigSLA$, obtained from a local register; (5) a set of \textit{data services}
%$DS$; (6) a set of \textit{data processing services} $DPS$; and (7) a set of \textit{cloud providers} $CP$. As output, the integration results $IR$ is delivered to the user while fulfilling her preferences and cloud subscription.
%%
 
%The approach begins looking for previous \textit{integrated SLAs} in our
%local registry. From each \textit{integrated SLA} we verify if it matches
%the user' query and preferences (lines 2 - 6), and adding them to the set $pI$ (line 4).
%%
%If previous \textit{integrated SLA} matches (line 7), the one that
%partially matches with the user preferences is selected (line 8).
%%
%Then, a new \textit{integrated SLA} is computed for user query based on the
%previous \textit{integrated SLA}, her preferences and cloud subscription (line 9).
%%
%The service compositions produced to a previous query is reused based its \textit{integrated SLA} ($sI$). 
%%
%Otherwise, a new \textit{integrated SLA} is created to user request given the query, her preferences and cloud subscription (line 11). 
%%
%The SLA information of $\mathit{DS}$ and $\mathit{DPS}$ is extracted and included in the set of \bigS (line 12). 
%%
%This new \textit{integrated SLA} is updated by calling the \textit{Rhone} procedure (line 13). 
%%
%The \textit{Rhone} is responsible of (i) selecting \textit{data services} (in $DS$) and \textit{data processing services} (in $DPS$) which satisfy the user preferences based on their SLAs; and (ii) producing service compositions that completely match with the query and fulfill the user preferences. 
%%
%Finally, the integration results ($IR$) are produced and delivered to the user considering her cloud subscription. 
%%
%Note that while executing compositions, it is necessary to satisfy the user requirements and cloud subscription, and also to dynamically update the \textit{integrated SLA} adding the information of contracts that were established to allow the integration. 
%%
%Finally, the \textit{integrated SLA} is stored in our registry to be used in a next query.   
%
%\begin{algorithm} 
%%\small
%\caption{ - SLA-based data integration}
%\label{qualityBasedAlgorithm}
%\begin{algorithmic}[1]
%\REQUIRE Query ($Q$), user preferences ($P$), user cloud subscriptions ($C$), a
%set of \textit{data services} ($\mathit{DS}$) and \textit{data processing services} ($\mathit{DPS}$) and a set of previous \textit{integrated SLA} ($\bigSLA$).
%\ENSURE Integration results delivered considering the user cloud subscription.
%%\STATE \textbf{function} $\mathit{SelectCandidateServices} (Q, \bigS)$
%%\STATE let $\bigSLA$ be a set of previous integrated SLA
%\STATE $pI \leftarrow \emptyset$
%\FORALL  {$SLA_{i}$ in $\bigSLA$}
%	\IF {$\mathit{macthes(Q, P, SLA_{i})}$}
%		\STATE $pI \leftarrow pI \cup \lbrace SLA_{i} \rbrace$		
%%		\FORALL  {$A_{j}$ in $S_{i}$}
%%			\IF {$Q.\mathit{notContains(A_{i})}$}
%%				\STATE $b \leftarrow \mathit{false}$	
%%				\STATE $\mathit{break}$
%%			\ENDIF
%%		\ENDFOR
%%		\IF {$b = true$}
%%			\STATE $\bigLS \leftarrow \bigLS \cup \lbrace S_{i} \rbrace$	
%%		\ENDIF
%	\ENDIF
%\ENDFOR
%\IF {$pI \neq \emptyset$}
%	\STATE $sI \leftarrow chooseBest(P, pI)$
%	\STATE $newSLA_{i} \leftarrow deriveSLA(sI, P, C)$
%%	\FORALL  {$SLA_{i}$ in $pI$}
%%		\STATE $sI \leftarrow choose(P,)$
%%	\ENDFOR
%\ELSE
%	\STATE $newSLA_{i} \leftarrow deriveSLA(Q, P, C)$
%	\STATE $\bigS \leftarrow extract(\mathit{DS}, \mathit{DPS})$
%	\STATE $newSLA_{i} \leftarrow updateSLA(Rhone(Q, \bigS))$
%\ENDIF
%\STATE $IR \leftarrow execute(newSLA_{i})$
%\STATE \textbf{return} $IR$
%\STATE \textbf{end function}
%\end{algorithmic}
%\end{algorithm} 

%\subsection{SLA-based query rewriting algorithm}
%To serve a proof of concept to our approach, we develop a query
%rewriting algorithm which is guided by users' integration requirements and
%service level agreements exported by different data services and cloud
%providers. Researches have refered to data integration as a service composition problem
%in which given a query the objective is to lookup and compose data services that
%can contribute to produce a result. Currently, we have formalized and developed a rewriting
%algorithm that considers user preferences and services' quality aspects while
%selecting services and producing rewritings called \textit{Rhone} (See algorithm
%\ref{algo-rhone}, invoked in the algorithm 1, line 12).
%The \textit{Rhone} algorithm consists in four macro steps: 
%\\
%\textbf{\underline{Selecting data services}}. The \textit{Rhone} looks for
%\textit{data services} (line 2) that can contribute to answer the query while
%satisfying the user' preferences; \\
%\textbf{\underline{Building candidate service descriptions}}. A candidate
%service description (CSD) describes how a \textit{data service} can contribute to answer the query. CSD maps a \textit{data service} (including its variables) to the entire query or part of it. For all selected services, the \textit{Rhone} tries to build CSDs when the mapping of variables is possible (line
%3). \\
%\textbf{\underline{Combining CSDs}}. All CSDs are combined (line 4) producing a
%list of CSD combinations. Each combination can be a rewriting of the query. \\
%\textbf{\underline{Producing rewritings}}. Each list of CSDs is checked in order
%to verify whether it is a rewriting of the query or not (line 9). To be a
%valid rewriting, it is forbidden to have CSDs covering the same part of the query.
%Rewritings are produced while the user' requirements are being respected (lines 6-14).
%%
%The originality of our algorithm concerns the functions ~\!\tqI{}, ~\!\tqT{} and ~\!\tqS{}.     
%They are responsible to initialize, check and increment user preferences
%associated to some aggregation like user constraints (total cost). This means
%that these preferences are initialized (line 6), and for each element in the CSD list they are incremented (line 11), and rewritings are produced while they are respected (line 8).  The result of this step is the list of valid rewritings of the query (line 14).
%
%\begin{algorithm}[h!]
%\small
%\caption{ - \textit{Rhone}}
%\label{algo-rhone}
%\begin{algorithmic}[1]
%\REQUIRE A query $Q$, a set of user preferences, and a set of concrete services $\bigS$.
%\ENSURE A set of rewritings $R$ that matches with the query and fulfill the user preferences.
%\STATE \textbf{function} $\mathit{Rhone} (Q, \bigS)$
% \STATE  $\bigLS \leftarrow \mathit{SelectCandidateServices}(Q, \bigS)$ \label{rhone:buildPCD}
% \STATE  $\bigLCSD \leftarrow CreateCSDs(Q, \bigLS)$
% \STATE  $I \leftarrow CombineCSDs(\bigLCSD)$
% \STATE $R\leftarrow \emptyset$
% \STATE ~\!\tqI{\agg{Q}} 
%    \STATE $p \leftarrow I.next()$
%    \WHILE {$p\ \neq\ \emptyset$ \AND ~\!\tqT{\agg{Q}}} 
%      \IF {\textit{isRewriting}$(Q, p)$}
%  \STATE $R\leftarrow R\,\cup \mathit{Rewriting}(p)$
%  \STATE ~\!\tqS{\agg{Q}}
%   \ENDIF
%      \STATE $p \leftarrow I.\mathit{next}()$
% \ENDWHILE
%    \STATE \textbf{return} $R$
%\STATE \textbf{end function}
%\end{algorithmic}
%\end{algorithm}
%
%To serve as a proof of concept to our approach, we intend to develop a query
%rewriting algorithm which is guided by users' integration requirements and
%service level agreements exported by different data services and cloud
%providers. The query rewriting is an important issue in data integration. In
%cloud computing, researches have refereed to it as a service composition problem
%in which given a query the objective is to lookup and compose data services that
%can contribute to produce a result. \cite{Barhamgi2010} proposed a query
%rewriting approach which processes queries on data provider services.
%\cite{Benouaret2011} introduced a service composition framework to answer
%preference queries. Two algorithms inspired on~\cite{Barhamgi2010} are presented
%to rank the best rewritings based on previously computed scores. \cite{ba2014}
%extended \cite{Umberto} and presented an refinement algorithm that produces and
%order rewritings according to user preferences and scores. In general, these
%works share the same performance problem depending on the size of the query and
%on the number of available services. Furthermore, they do not take into
%consideration user's integration requirements what can lead to produce
%rewritings that are not satisfactory to the user in terms of quality
%requirements and cost. Currently, we have formalized and developed a rewriting
%algorithm that considers user preferences and services' quality aspects while
%selecting services and producing rewritings called \textit{Rhone} (Invoked in the algorithm 1, line 12).                     