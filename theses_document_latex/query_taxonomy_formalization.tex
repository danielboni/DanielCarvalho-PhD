\chapter{No-name yet}

\newpage

\section{Query taxonomy and re-usability formalization}

This section presents the description and formalization of the different types of queries which \textit{(i)} can be processed by our integration approach; and \textit{(ii)} can be compared to previous integration requests in order to take advantage from previous integration plans. The query definition is introduced below.

\begin{definition}
A query is defined as a $n$-tuple:
%
\begin{center}
$Q := \langle A, R, S, C, w  \rangle$
\end{center}
%
where: $A$ is a set of abstract services defining the query $Q$;
$R$ is a set of user preferences that can be defined over the data services or the entire query;
$S$ is a set of data services that were selected satisfying the restrictions defined by $R$ to potentially rewrite the query $Q$;
$C$ is a set of compositions that were produced using the data services in $S$ and satisfying the restrictions defined by $R$ that potentially can answer the query $Q$; and
$w$ is the composition that were selected and executed to answer the query $Q$. 
\end{definition}

The query taxonomy proposed below is defined according to the type of relation that can be established between two queries. 
Queries are classified in four groups: 
\begin{itemize}
\item \textit{Group 1:} The data denoted by the answer of $Q_{1}$ is the same data expected by the answer of $Q_{2}$. For example, $Q_{1}$ and $Q_{2}$ retrieve patients that were infected by pneumonia.
\item \textit{Group 2:} The data denoted by the answer of $Q_{1}$ is a subset of the data denoted by the answer of $Q_{2}$. For example, $Q_{2}$ retrieves patients that were infected by pneumonia and $Q_{1}$ retrieves patients that were infected by pneumonia and treated by the doctor Lucas.
\item \textit{Group 3:} The data denoted by the answer of $Q_{1}$ is a superset of the data denoted by the answer of $Q_{2}$. For example, $Q_{2}$ retrieves patients that were infected by pneumonia and treated by the doctor Lucas, and $Q_{1}$ retrieves patients that were infected by pneumonia.
\item \textit{Group 4:} The data denoted by the answer of $Q_{1}$ is different of the data denoted by the answer of $Q_{2}$. For example, $Q_{2}$ retrieves patients that were infected by pneumonia and treated by the doctor Lucas, and $Q_{1}$ retrieves patients that were infected by pneumonia with admission in the hospital Edouard Herriot.
\end{itemize}

To understand the different types of query, basic concepts regarding \textit{(i)} user requirements, \textit{(ii)} requirements domain, \textit{(iii)} requirements evaluation and \textit{(iv)} comparable requirements should be introduced:

\begin{definition}
An user requirement $r$ is in the form $x \otimes c$, where $x$ is an identifier; $c$ is a constant; and $\otimes \in\lbrace \geq, \leq, =, \neq, <, >\rbrace$. 
%
The user requirement $r$ could concern \textit{(i)} the entire \textsl{query}, in this case noted as $r_{Q}$; or \textit{(ii)} a single service, noted as $r_{S}$. For instance, the total response time is obtained by adding the response time of each service involved in the composition.
\end{definition}

\begin{definition}
A requirement domain is a set of possible values which can be assumed by an user requirement $r$, represented by $Dom(r)$. 
For instance, a requirement domain ``response time'' includes the possible values associated to the response time user requirement. 
Each user requirement $r_{i}$ has its own requirement domain $D_{i}$. 
\end{definition}

\begin{definition}
The evaluation of an user requirement $r$, indicated by $eval(r)$, returns a set of values $\lbrace v_{1},..,v_{i} \rbrace$ that can be assigned to $r$ such that $\lbrace v_{1},..,v_{i} \rbrace \subset Dom(r)$.
\end{definition}

\begin{definition}
Given two user requirements $r_{1}$ and $r_{2}$, both can be comparable, denoted by $r_{1} \perp r_{2}$, if and only if:  $Dom(r_{1}) = Dom(r_{2})$.
\end{definition}

The thirteen types of queries included in the taxonomy described in the following sections are organized according to their groups.

\subsection{Queries belonging to the Group 1}

Group 1 contains queries of four different types: \textit{(i)} equivalent; \textit{(ii)} subset; \textit{(iii)} superset; and \textit{(iv)} a special case. 

\subsubsection{Query type 1: $Q_{1}$ is equivalent to $Q_{2}$}

The \textit{first} type deals with \textit{equivalent queries}. Two queries $Q_{1}$ and $Q_{2}$ are equivalent when:
%
\begin{enumerate}[a)]
\item They expect the same data as answer, which means they cover the same abstract services. For instance, the set of abstract service of $Q_{1}$, denoted as $Q_{1}.A$, is equals to the set of abstract services of $Q_{2}$, denoted as $Q_{2}.A$.
%
\begin{center}
$Q_{1}.A = Q_{2}.A$
\end{center}
%
\item For each user requirement $r_{i}$ in $Q_{1}.R$, there is a user requirement $r_{j}$ in $Q_{2}.R$ such that the evaluation of $r_{i}$ is equal to the evaluation of $r_{j}$. 
Consequently, the score of $Q_{1}.R$ is equals to the score of $Q_{2}.R$. The equivalence between requirements is defined below.
\end{enumerate}

\begin{definition}\label{def:reqeq}
A set of \textsl{user requirements} $R_{1}$ is equivalent to a set of \textsl{user requirements} $R_{2}$, represented by $R_{1} \equiv R_{2}$, if and only if: $\forall r_{i} \in R_{1}, \ \exists r_{j} \in R_{2} \ \vert \ eval (r_{i}) = eval(r_{j}) \ and \ \vert R_{1} \vert = \vert R_{2} \vert$.
\end{definition}

From the re-usability point of view, all data services filtered to the query $Q_{1}$ which are \textit{online} in the moment, denoted $online(Q_{1}.S)$, could be reused in the query $Q_{2}$. 
Moreover, the rewritings (compositions) produced to the query $Q_{1}$ which use the data services in $online(Q_{1}.S)$, denoted as $available(Q_{1}.C)$, could also be used to answer the query $Q_{2}$. The query type 1 definition is presented below.

\begin{definition}\label{def:qt1}
Query Type 1 -- a query $Q_{1}$ is equivalent to a query $Q_{2}$, if and only if: $Q_{1}.A = Q_{2}.A$ and $Q_{1}.R_{1} \equiv Q_{2}.R_{2}$
\end{definition}

\subsubsection{Query type 2: $Q_{2}$ is a subset of $Q_{1}$}

The \textit{second} type deals with \textit{query subsets} due to more restrict user requirements. Given two queries $Q_{1}$ and $Q_{2}$, $Q_{2}$ is a subset of $Q_{1}$ when:
%
\begin{enumerate}[a)]
\item They expect the same data as answer, which means they cover the same abstract services. 
For instance, the set of abstract service of $Q_{1}$, denoted as $Q_{1}.A$, is equals to the set of abstract services of $Q_{2}$, denoted as $Q_{2}.A$.
%
\begin{center}
$Q_{1}.A = Q_{2}.A$
\end{center}
%
\item For all user requirement $r_{i}$ in $Q_{2}.R$, there is at least one $r_{j}$ in $Q_{1}.R$ such that the evaluation of $r_{i}$ is contained in the evaluation of $r_{j}$. 
For all $r_{k}$ in $Q_{2}.R$, there is no $r_{l}$ in $Q_{1}.R$ such that the evaluation of $r_{l}$ is contained in the evaluation of $r_{k}$. 
Consequently, the score of $Q_{1}.R$ is lower than the score of $Q_{2}.R$. The definition of more restrict requirements is presented below.
\end{enumerate}

\begin{definition}\label{def:reqmore}
Given a set of \textsl{user requirements} $R_{1}$ and $R_{2}$, $R_{1}$ is more restrict than $R_{2}$, represented by $R_{1} \ \rhd \ R_{2}$, if and only if: $\forall r_{i} \in R_{1}, \ \exists r_{j} \in R_{2}, \ \nexists r_{k} \in R_{2} \ \vert \ eval (r_{i}) \subset eval(r_{j}) \ and \ eval (r_{k}) \subset eval(r_{i}) \ and \ \vert R_{1} \vert = \vert R_{2} \vert$.
\end{definition}

From the re-usability point of view, a subset of the data services filtered to the query $Q_{1}$ which are \textit{online} in the moment, $online(Q_{1}.S)$, could be reused in the query $Q_{2}$. This fact occurs due to the more restrict requirements imposed by $Q_{2}$.
With respect to the compositions, a subset of the rewritings produced to the query $Q_{1}$ could also be used to answer the query $Q_{2}$. These rewritings should use the data services in $online(Q_{1}.S)$, denoted as $available(Q_{1}.C)$, and respect the more restrict requirements defined in $Q_{2}$. 
The query type 2 definition is presented below.

\begin{definition}\label{def:qt2}
Query Type 2 -- a query $Q_{1}$ is a subset of a query $Q_{2}$, if and only if: $Q_{1}.A = Q_{2}.A$ and $Q_{1}.R_{1} \rhd Q_{2}.R_{2}$
\end{definition}
